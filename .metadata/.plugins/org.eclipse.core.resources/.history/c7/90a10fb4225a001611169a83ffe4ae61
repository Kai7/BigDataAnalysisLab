package KaiSeven;

import java.awt.print.Printable;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class FPGrowth {
	// public static final String ANSI_RESET = "\033[0m";
	// public static final String ANSI_RED = "\033[31m";
	// public static final String ANSI_YELLOW = "\033[33m";

	// private ArrayList<ArrayList<Integer>> DataSet;
	// private HashSet<ItemsetSupport> FrequentItemsets;
	private FrequentPatternTree frequentPattermTree;
	private HeaderTable headerTable;
	private int ItemsCount;
	private double min_sup_ratio;
	private int min_sup;

	public FPGrowth(String inDataPath, String outDataPath, double minsupRatio) {
		Scanner DataInput = null;
		try {
			DataInput = new Scanner(new FileInputStream(inDataPath));
		} catch (FileNotFoundException e) {
			System.out.println("input file error!");
			System.exit(0);
		}

		// First Scan Database & Count Frequent Item Table
		HashMap<Integer, Integer> countItemFrequency = new HashMap<Integer, Integer>();
		int countTransaction = 0;
		int tmpItemNum;
		StringTokenizer tmpTokenizer = null;
		while (DataInput.hasNextLine()) {
			countTransaction += 1;
			tmpTokenizer = new StringTokenizer(DataInput.nextLine(), " ,");
			while (tmpTokenizer.hasMoreTokens()) {
				tmpItemNum = Integer.parseInt(tmpTokenizer.nextToken());
				if (countItemFrequency.get(tmpItemNum) == null)
					countItemFrequency.put(tmpItemNum, 1);
				else
					countItemFrequency.put(tmpItemNum, countItemFrequency.get(tmpItemNum) + 1);
			}
		}

		int tmpItemCount;
		LinkedList<ItemSup> frequentItemList = new LinkedList<ItemSup>();
		for (int item : countItemFrequency.keySet()) {
			tmpItemCount = countItemFrequency.get(item);
			if (tmpItemCount >= min_sup)
				frequentItemList.add(new ItemSup(item, tmpItemCount));
		}

		ItemSup[] frequentItemTable = new ItemSup[frequentItemList.size()];
		for (int i = 0; i < frequentItemTable.length; i++)
			frequentItemTable[i] = frequentItemList.remove();
		Arrays.sort(frequentItemTable, new ItemSupComparator());

		min_sup_ratio = minsupRatio;
		min_sup = (int) Math.ceil(min_sup_ratio * countTransaction);

		// Build Compare Map & Frequent Item Set
		HashMap<Integer, Integer> orderItemMap = new HashMap<Integer, Integer>();
		HashSet<Integer> frequentItemSet = new HashSet<Integer>();
		for (int i = 0; i < frequentItemTable.length; i++) {
			orderItemMap.put(frequentItemTable[i].item, i);
			frequentItemSet.add(frequentItemTable[i].item);
		}

		// Second Scan Database
		// Delete Non-Frequent Items & Sort by Compare Map
		// Build Header Table and FP-Tree
		try {
			DataInput = new Scanner(new FileInputStream(inDataPath));
		} catch (FileNotFoundException e) {
			System.out.println("input file error!");
			System.exit(0);
		}

		headerTable = new HeaderTable(frequentItemTable);
		FPNode[] ptrRearHTable = new FPNode[headerTable.length];
		for (int i = 0; i < ptrRearHTable.length; i++)
			ptrRearHTable[i] = null;

		frequentPattermTree = new FrequentPatternTree();

		LinkedList<Integer> tmpTransactionList = new LinkedList<Integer>();
		while (DataInput.hasNextLine()) {
			tmpTokenizer = new StringTokenizer(DataInput.nextLine(), " ,");
			while (tmpTokenizer.hasMoreTokens()) {
				tmpItemNum = Integer.parseInt(tmpTokenizer.nextToken());
				if (frequentItemSet.contains(tmpItemNum))
					tmpTransactionList.add(tmpItemNum);
			}
			Collections.sort(tmpTransactionList, new OrderItemMapComparator());

			frequentPattermTree.addNewTransaction(tmpTransactionList, orderItemMap);
		}

		// System.out.println("--Data Information----------------------");
		// System.out.println("DataSet.size() : " + DataSet.size() +
		// " and  min_sup : " + min_sup);
		// System.out.println("----------------------------------------");

		HashSet<Integer> emptyItemSet = new HashSet<Integer>();
		mining(frequentPattermTree, headerTable, emptyItemSet);
	}

	public void mining(FrequentPatternTree FPTree, HeaderTable HTable, HashSet<Integer> ItemSet) {
		if (HTable.length == 0)
			return;

		// System.out.println("HeaderTable size : " + HT.length);
		FrequentPatternTree subFPTree = null; 	// recursive variable
		HeaderTable subHTable = null; 			// recursive variable
		HashSet<Integer> expItemSet = null; 	// recursive variable
		
		FPNode ptrFPNode = null;
		FPNode ptrParentFPNode = null;
		HashSet<Integer> tmpFreqItemSet = null;
		HashMap<Integer, Integer> countItemFrequency = null;
		HashMap<Integer, Integer> tmpItemMap = null;
		// ArrayList<Integer> tmpFreqItemList = null;
		ItemsetSupport tmpItemsetSup = null;
		int Count;
		int Index;
		for (int i = 0; i < HTable.length; i++) {
			// HT.HTNodeArr[i].item);
			ptrFPNode = HTable.HTNodeArr[i].headerFPNode;
			if (ptrFPNode == null)
				System.out.println("error");
			Count = 0;
			expItemSet = new HashSet<Integer>(ItemSet);
			expItemSet.add(ptrFPNode.item);
			countItemFrequency = new HashMap<Integer, Integer>();
			while (ptrFPNode != null) {
				Count += ptrFPNode.count;
				ptrParentFPNode = ptrFPNode.parent;
				while (ptrParentFPNode.item != -1) {
					if (countItemFrequency.get(ptrParentFPNode.item) != null)
						countItemFrequency.put(ptrParentFPNode.item, countItemFrequency.get(ptrParentFPNode.item) + ptrFPNode.count);
					else
						countItemFrequency.put(ptrParentFPNode.item, ptrFPNode.count);
					ptrParentFPNode = ptrParentFPNode.parent;
				}
				ptrFPNode = ptrFPNode.nextFP;
			}
			tmpItemsetSup = new ItemsetSupport(expItemSet, Count);
			System.out.println(tmpFreqItemSet.toString());
			tmpFreqItemSet = new HashSet<Integer>();
			for (int item : countItemFrequency.keySet()) {
				if (countItemFrequency.get(item) >= min_sup)
					tmpFreqItemSet.add(item);
			}
			if (tmpFreqItemSet.size() == 0)
				continue;
			countItemFrequency = null;

			// create new sub-FPtree and HeaderTable
			ptrFPNode = HTable.HTNodeArr[i].headerFPNode;
			// tmpFreqItemList = new ArrayList<Integer>(tmpFreqItemSet);
			// initial HeaderTable and buildtmpItemMap
			// this version is non-order for HeaderTable
			subHTable = new HeaderTable(tmpFreqItemSet.size());
			tmpItemMap = new HashMap<Integer, Integer>();
			Index = 0;
			for (int item : tmpFreqItemSet) {
				subHTable.HTNodeArr[Index] = new HTNode(item);
				tmpItemMap.put(item, Index);
				Index += 1;
			}
			FPNode tmpNewFPNode = null;
			FPNode ptrInsertNode = null;
			FPNode ptrSearchNode = null;
			subFPTree = new FrequentPatternTree();
			while (ptrFPNode != null) {
				// System.out.println("build sub-branch & sub-tree...");
				// new a sub-branch
				ptrParentFPNode = ptrFPNode.parent;
				while (ptrParentFPNode.item != -1 && !(tmpFreqItemSet.contains(ptrParentFPNode.item))) {
					ptrParentFPNode = ptrParentFPNode.parent;
				}

				if (ptrParentFPNode.item == -1) { // this branch has no frequent
												// pattern list
					ptrFPNode = ptrFPNode.nextFP;
					continue;
				}

				tmpNewFPNode = new FPNode();
				tmpNewFPNode.item = ptrParentFPNode.item;
				tmpNewFPNode.count = ptrFPNode.count;

				ptrParentFPNode = ptrParentFPNode.parent;
				while (ptrParentFPNode.item != -1) {
					while (ptrParentFPNode.item != -1 && !(tmpFreqItemSet.contains(ptrParentFPNode.item))) {
						ptrParentFPNode = ptrParentFPNode.parent;
					}
					if (ptrParentFPNode.item == -1)
						break;
					tmpNewFPNode.parent = new FPNode();
					tmpNewFPNode.parent.firstchild = tmpNewFPNode;
					tmpNewFPNode = tmpNewFPNode.parent;
					tmpNewFPNode.item = ptrParentFPNode.item;
					tmpNewFPNode.count = ptrFPNode.count;
					ptrParentFPNode = ptrParentFPNode.parent;
				}
				// add the sub-branch to subTree & link tmpHeaderTable to the
				// branch
				ptrInsertNode = subFPTree.root;
				while (tmpNewFPNode != null) {
					// if the insert root is leaf
					if (ptrInsertNode.firstchild == null) {
						ptrInsertNode.firstchild = tmpNewFPNode;
						tmpNewFPNode.parent = ptrInsertNode;
						while (tmpNewFPNode != null) {
							Index = tmpItemMap.get(tmpNewFPNode.item);
							if (subHTable.HTNodeArr[Index].headerFPNode == null) {
								subHTable.HTNodeArr[Index].headerFPNode = tmpNewFPNode;
								tmpHTrearPointer[Index] = tmpNewFPNode;
							} else {
								tmpHTrearPointer[Index].nextFP = tmpNewFPNode;
								tmpHTrearPointer[Index] = tmpNewFPNode;
							}
							tmpNewFPNode = tmpNewFPNode.firstchild;
						}
						break;
					} else {
						// search the fit node
						// the fit node is firstchild
						ptrSearchNode = ptrInsertNode.firstchild;
						if (ptrSearchNode.item == tmpNewFPNode.item) {
							ptrSearchNode.count += tmpNewFPNode.count;
							tmpNewFPNode = tmpNewFPNode.firstchild;
							ptrInsertNode = ptrSearchNode;
							continue;
						}
						// the fit node is not firstchild
						while (ptrSearchNode.next != null) {
							if (ptrSearchNode.next.item == tmpNewFPNode.item)
								break;
							ptrSearchNode = ptrSearchNode.next;
						}
						// if no fit node
						if (ptrSearchNode.next == null) {
							ptrSearchNode.next = tmpNewFPNode;
							tmpNewFPNode.parent = ptrInsertNode;
							while (tmpNewFPNode != null) {
								Index = tmpItemMap.get(tmpNewFPNode.item);
								if (subHTable.HTNodeArr[Index].headerFPNode == null) {
									subHTable.HTNodeArr[Index].headerFPNode = tmpNewFPNode;
									tmpHTrearPointer[Index] = tmpNewFPNode;
								} else {
									tmpHTrearPointer[Index].nextFP = tmpNewFPNode;
									tmpHTrearPointer[Index] = tmpNewFPNode;
								}
								tmpNewFPNode = tmpNewFPNode.firstchild;
							}
							break;
						}

						// there is fit node
						ptrSearchNode.next.count += tmpNewFPNode.count;
						tmpNewFPNode = tmpNewFPNode.firstchild;
						ptrInsertNode = ptrSearchNode.next;
						continue;
					}
				}
				// update tmpFPNode
				ptrFPNode = ptrFPNode.nextFP;
			}
			miningSubTree(subFPTree, subHTable, expItemSet);
		}

	}

	private void miningSubTree(FrequentPatternTree Tree, HeaderTable HT, HashSet<Integer> ItemSet) {
		// System.out.println("HeaderTable size : " + HT.length);
		FrequentPatternTree tmpTree = null; // recursive variable
		HeaderTable tmpHT = null; // recursive variable
		FPNode[] tmpHTrearPointer = null;
		FPNode tmpFPNode = null;
		FPNode tmpPointer = null;
		HashSet<Integer> tmpItemSet = null; // recursive variable
		HashSet<Integer> tmpFreqItemSet = null;
		HashMap<Integer, Integer> ItemCount = null;
		HashMap<Integer, Integer> tmpItemMap = null;
		// ArrayList<Integer> tmpFreqItemList = null;
		ItemsetSupport tmpItemsetSup = null;
		int Count;
		int Index;
		for (int i = 0; i < HT.length; i++) {
			// System.out.println("i:" + i + " for item : " +
			// HT.HTNodeArr[i].item);
			tmpFPNode = HT.HTNodeArr[i].headerFPNode;
			if (tmpFPNode == null)
				System.out.println("error");
			Count = 0;
			tmpItemSet = new HashSet<Integer>(ItemSet);
			tmpItemSet.add(tmpFPNode.item);
			ItemCount = new HashMap<Integer, Integer>();
			while (tmpFPNode != null) {
				Count += tmpFPNode.count;
				tmpPointer = tmpFPNode.parent;
				while (tmpPointer.item != -1) {
					if (ItemCount.get(tmpPointer.item) != null)
						ItemCount.put(tmpPointer.item, ItemCount.get(tmpPointer.item) + tmpFPNode.count);
					else
						ItemCount.put(tmpPointer.item, tmpFPNode.count);
					tmpPointer = tmpPointer.parent;
				}
				tmpFPNode = tmpFPNode.nextFP;
			}
			tmpItemsetSup = new ItemsetSupport(tmpItemSet, Count);
			FrequentItemsets.add(tmpItemsetSup);
			tmpFreqItemSet = new HashSet<Integer>();
			for (int item : ItemCount.keySet()) {
				if (ItemCount.get(item) >= min_sup)
					tmpFreqItemSet.add(item);
			}
			if (tmpFreqItemSet.size() == 0)
				continue;
			ItemCount = null;

			// create new sub-FPtree and HeaderTable
			tmpFPNode = HT.HTNodeArr[i].headerFPNode;
			// tmpFreqItemList = new ArrayList<Integer>(tmpFreqItemSet);
			// initial HeaderTable and buildtmpItemMap
			// this version is non-order for HeaderTable
			tmpHT = new HeaderTable(tmpFreqItemSet.size());
			tmpItemMap = new HashMap<Integer, Integer>();
			Index = 0;
			for (int item : tmpFreqItemSet) {
				tmpHT.HTNodeArr[Index] = new HTNode(item);
				tmpItemMap.put(item, Index);
				Index += 1;
			}
			tmpHTrearPointer = new FPNode[tmpHT.length];
			for (int j = 0; j < tmpHTrearPointer.length; j++) {
				tmpHTrearPointer[j] = null;
			}
			FPNode tmpNewFPNode = null;
			FPNode tmpInsertPointer = null;
			FPNode tmpSearchPointer = null;
			tmpTree = new FrequentPatternTree();
			while (tmpFPNode != null) {
				// System.out.println("bulid sub-branch & sub-tree...");
				// new a sub-branch
				tmpPointer = tmpFPNode.parent;
				while (tmpPointer.item != -1 && !(tmpFreqItemSet.contains(tmpPointer.item))) {
					tmpPointer = tmpPointer.parent;
				}

				if (tmpPointer.item == -1) { // this branch has no frequent
												// pattern list
					tmpFPNode = tmpFPNode.nextFP;
					continue;
				}

				tmpNewFPNode = new FPNode();
				tmpNewFPNode.item = tmpPointer.item;
				tmpNewFPNode.count = tmpFPNode.count;

				tmpPointer = tmpPointer.parent;
				while (tmpPointer.item != -1) {
					while (tmpPointer.item != -1 && !(tmpFreqItemSet.contains(tmpPointer.item))) {
						tmpPointer = tmpPointer.parent;
					}
					if (tmpPointer.item == -1)
						break;
					tmpNewFPNode.parent = new FPNode();
					tmpNewFPNode.parent.firstchild = tmpNewFPNode;
					tmpNewFPNode = tmpNewFPNode.parent;
					tmpNewFPNode.item = tmpPointer.item;
					tmpNewFPNode.count = tmpFPNode.count;
					tmpPointer = tmpPointer.parent;
				}
				// add the sub-branch to subTree & link tmpHeaderTable to the
				// branch
				tmpInsertPointer = tmpTree.root;
				while (tmpNewFPNode != null) {
					// if the insert root is leaf
					if (tmpInsertPointer.firstchild == null) {
						tmpInsertPointer.firstchild = tmpNewFPNode;
						tmpNewFPNode.parent = tmpInsertPointer;
						while (tmpNewFPNode != null) {
							Index = tmpItemMap.get(tmpNewFPNode.item);
							if (tmpHT.HTNodeArr[Index].headerFPNode == null) {
								tmpHT.HTNodeArr[Index].headerFPNode = tmpNewFPNode;
								tmpHTrearPointer[Index] = tmpNewFPNode;
							} else {
								tmpHTrearPointer[Index].nextFP = tmpNewFPNode;
								tmpHTrearPointer[Index] = tmpNewFPNode;
							}
							tmpNewFPNode = tmpNewFPNode.firstchild;
						}
						break;
					} else {
						// search the fit node
						// the fit node is firstchild
						tmpSearchPointer = tmpInsertPointer.firstchild;
						if (tmpSearchPointer.item == tmpNewFPNode.item) {
							tmpSearchPointer.count += tmpNewFPNode.count;
							tmpNewFPNode = tmpNewFPNode.firstchild;
							tmpInsertPointer = tmpSearchPointer;
							continue;
						}
						// the fit node is not firstchild
						while (tmpSearchPointer.next != null) {
							if (tmpSearchPointer.next.item == tmpNewFPNode.item)
								break;
							tmpSearchPointer = tmpSearchPointer.next;
						}
						// if no fit node
						if (tmpSearchPointer.next == null) {
							tmpSearchPointer.next = tmpNewFPNode;
							tmpNewFPNode.parent = tmpInsertPointer;
							while (tmpNewFPNode != null) {
								Index = tmpItemMap.get(tmpNewFPNode.item);
								if (tmpHT.HTNodeArr[Index].headerFPNode == null) {
									tmpHT.HTNodeArr[Index].headerFPNode = tmpNewFPNode;
									tmpHTrearPointer[Index] = tmpNewFPNode;
								} else {
									tmpHTrearPointer[Index].nextFP = tmpNewFPNode;
									tmpHTrearPointer[Index] = tmpNewFPNode;
								}
								tmpNewFPNode = tmpNewFPNode.firstchild;
							}
							break;
						}

						// there is fit node
						tmpSearchPointer.next.count += tmpNewFPNode.count;
						tmpNewFPNode = tmpNewFPNode.firstchild;
						tmpInsertPointer = tmpSearchPointer.next;
						continue;
					}
				}
				// update tmpFPNode
				tmpFPNode = tmpFPNode.nextFP;
			}
			miningSubTree(tmpTree, tmpHT, tmpItemSet);
		}

	}

	public String getSimpleResult() {
		String Result = new String();
		Result += "========================================\n";
		Result += "FPGrowth Mining Result\n";
		Result += "Data size : " + DataSet.size() + " and  min_sup : " + ANSI_RED + min_sup_ratio + ANSI_RESET + "\n";
		Result += "There are " + ANSI_YELLOW + FrequentItemsets.size() + ANSI_RESET + " frequent itemsets !\n";
		Result += "========================================\n";
		return Result;
	}

	private class FrequentPatternTree {
		public FPNode root;

		public FrequentPatternTree() {
			root = new FPNode();
		}

		public void addNewTransaction(LinkedList<Integer> someTransaction, HashMap<Integer, Integer> orderItemMap) {
			FPNode ptrCurrentNode = root;
			FPNode ptrSearchNode = null;
			FPNode tmpNode = null;
			int tmpItem;
			int tmpItemMapNum;

			for (int i = 0; i < someTransaction.size(); i++) {
				tmpItem = someTransaction.remove();
				if (ptrCurrentNode.firstchild == null) {
					tmpNode = new FPNode(tmpItem, 1);
					tmpNode.parent = ptrCurrentNode;
					ptrCurrentNode.firstchild = tmpNode;
					tmpItemMapNum = orderItemMap.get(tmpItem);
					if (headerTable.HTNodeArr[tmpItemMapNum].rearFPNode == null)
						headerTable.HTNodeArr[tmpItemMapNum].headerFPNode = tmpNode;
					else
						headerTable.HTNodeArr[tmpItemMapNum].rearFPNode.nextFP = tmpNode;
					headerTable.HTNodeArr[tmpItemMapNum].rearFPNode = tmpNode;

					ptrCurrentNode = ptrCurrentNode.firstchild;
				} else {
					// linear search the item
					ptrSearchNode = ptrCurrentNode.firstchild;
					if (ptrSearchNode.item == tmpItem) {
						ptrSearchNode.count += 1;
						ptrCurrentNode = ptrSearchNode;
					} else {
						while (ptrSearchNode.next != null) {
							if (ptrSearchNode.next.item == tmpItem)
								break;
							ptrSearchNode = ptrSearchNode.next;
						}
						if (ptrSearchNode.next != null) {
							ptrSearchNode.next.count += 1;
							ptrCurrentNode = ptrSearchNode.next;
						} else {
							tmpNode = new FPNode(tmpItem, 1);
							tmpNode.parent = ptrCurrentNode;
							ptrSearchNode.next = tmpNode;
							tmpItemMapNum = orderItemMap.get(tmpItem);
							if (headerTable.HTNodeArr[tmpItemMapNum].rearFPNode == null)
								headerTable.HTNodeArr[tmpItemMapNum].headerFPNode = tmpNode;
							else
								headerTable.HTNodeArr[tmpItemMapNum].rearFPNode.nextFP = tmpNode;
							headerTable.HTNodeArr[tmpItemMapNum].rearFPNode = tmpNode;

							ptrCurrentNode = ptrCurrentNode.firstchild;
						}
					}
				}
			}
		}
	}

	private class HeaderTable {
		private HTNode[] HTNodeArr;
		private int length;

		public HeaderTable() {
			HTNodeArr = null;
			length = 0;
		}

		public HeaderTable(int Size) {
			HTNodeArr = new HTNode[Size];
			length = Size;
		}

		public HeaderTable(ItemSup[] frequentItemTable) {
			HTNodeArr = new HTNode[frequentItemTable.length];
			for (int i = 0; i < frequentItemTable.length; i++)
				HTNodeArr[i] = new HTNode(frequentItemTable[i].item);
			length = HTNodeArr.length;
		}

		public HTNode getNodeOfItemNum(int itemNum) {
			return HTNodeArr[OrderItemMap.get(itemNum)];
		}

		public void show() {
			System.out.print(HTNodeArr[0].item);
			for (int i = 1; i < HTNodeArr.length; i++) {
				System.out.print(" < " + HTNodeArr[i].item);
			}
			System.out.print("\n");
		}
	}

	private class FPNode {
		public int item;
		public int count;
		public FPNode parent;
		public FPNode firstchild;
		public FPNode next;
		public FPNode nextFP;

		public FPNode() {
			item = -1;
			count = 0;
			parent = null;
			firstchild = null;
			next = null;
			nextFP = null;
		}

		public FPNode(int it) {
			item = it;
			count = 0;
			parent = null;
			firstchild = null;
			next = null;
			nextFP = null;
		}

		public FPNode(int it, int c) {
			item = it;
			count = c;
			parent = null;
			firstchild = null;
			next = null;
			nextFP = null;
		}
	}

	private class HTNode {
		public int item;
		public FPNode headerFPNode;
		public FPNode rearFPNode;

		public HTNode() {
			item = -1;
			headerFPNode = null;
			rearFPNode = null;
		}

		public HTNode(int it) {
			item = it;
			headerFPNode = null;
			rearFPNode = null;
		}
	}

	private class ItemSup {
		public int item;
		public int supper;

		public ItemSup() {
			item = -1;
			supper = 0;
		}

		public ItemSup(int it) {
			item = it;
			supper = 0;
		}

		public ItemSup(int it, int sup) {
			item = it;
			supper = sup;
		}
	}

	private class ItemsetSupport {
		public HashSet<Integer> itemset;
		public int support;

		public ItemsetSupport() {
			itemset = new HashSet<Integer>();
			support = 0;
		}

		public ItemsetSupport(HashSet<Integer> its) {
			itemset = new HashSet<Integer>(its);
			support = 0;
		}

		public ItemsetSupport(HashSet<Integer> its, int sup) {
			itemset = new HashSet<Integer>(its);
			support = sup;
		}

		public void show() {
			Iterator<Integer> itor = itemset.iterator();
			System.out.print("{ " + itor.next());
			while (itor.hasNext()) {
				System.out.print(", " + itor.next());
			}
			System.out.println(" } : " + support);
		}
	}

	private class ItemSupComparator implements Comparator<ItemSup> {
		@Override
		public int compare(ItemSup i1, ItemSup i2) {
			if (i1.supper == i2.supper)
				return i2.item - i1.item;
			return i1.supper - i2.supper;
		}
	}

	private class OrderItemMapComparator implements Comparator<Integer> {
		HashMap<Integer, Integer> CompareMap;

		public OrderItemMapComparator() {
			CompareMap = null;
		}

		public OrderItemMapComparator(HashMap<Integer, Integer> IMap) {
			CompareMap = IMap;
		}

		// this design is for decreasing sort
		@Override
		public int compare(Integer i1, Integer i2) {
			return CompareMap.get(i2) - CompareMap.get(i1);
		}
	}
}

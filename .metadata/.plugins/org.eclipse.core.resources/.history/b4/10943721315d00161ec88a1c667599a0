package KaiSeven;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.StringTokenizer;

public class DBSCAN2d {
	double Eps;
	int minPts;
	Graph2d graph2d;

	public DBSCAN2d(String inDataPath, String outDataPath, double eps, int minpts) {
		Scanner dataInput = null;
		try {
			dataInput = new Scanner(new FileInputStream(inDataPath));
		} catch (FileNotFoundException e) {
			System.out.println("input file error!");
			System.exit(0);
		}
		Eps = eps;
		minPts = minpts;

		LinkedList<Point2d> tmpPoint2dList = new LinkedList<Point2d>();
		Point2d tmpPoint2d;
		double tmpx, tmpy;

		StringTokenizer tokenizer;
		tokenizer = new StringTokenizer(dataInput.nextLine());
		tmpx = Double.parseDouble(tokenizer.nextToken());
		tmpy = Double.parseDouble(tokenizer.nextToken());
		tmpPoint2d = new Point2d(tmpx, tmpy);
		tmpPoint2dList.add(tmpPoint2d);
		while (dataInput.hasNext()) {
			tokenizer = new StringTokenizer(dataInput.nextLine());
			tmpx = Double.parseDouble(tokenizer.nextToken());
			tmpy = Double.parseDouble(tokenizer.nextToken());
			tmpPoint2d = new Point2d(tmpx, tmpy);

			Iterator<Point2d> tmpListIterator = tmpPoint2dList.listIterator();
			while (tmpListIterator.hasNext()) {
				Point2d tmpOtherPoint2d = tmpListIterator.next();
				determineNeighbor(tmpPoint2d, tmpOtherPoint2d);
			}

			tmpPoint2dList.add(tmpPoint2d);
		}

	}

	private void determineNeighbor(Point2d p1, Point2d p2) {
		if (Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)) <= Eps) {
			p1.neighborPoints.add(p2);
			p2.neighborPoints.add(p1);
		}
		return;
	}

	private class Graph2d {
		public Point2d[] point2ds;

		public Graph2d(LinkedList<Point2d> Point2dList) {
			int countNonNoise = 0;

			Point2d[] point2ds = new Point2d[Point2dList.size()];
			LinkedList<Integer> tmpNonCorePointIndexList = new LinkedList<Integer>();
			for (int i = 0; i < point2ds.length; i++) {
				point2ds[0] = Point2dList.remove();
				if (point2ds[0].neighborPoints.size() >= minPts) {
					point2ds[0].flag = 'c';
					countNonNoise += 1;
				} else
					tmpNonCorePointIndexList.add(i);
			}

			while (tmpNonCorePointIndexList.size() > 0) {
				int index = tmpNonCorePointIndexList.remove();
				LinkedList<Point2d> neighbors = point2ds[index].neighborPoints;
				Iterator<Point2d> tmpPoint2dIterator = neighbors.listIterator();
				while (tmpPoint2dIterator.hasNext()) {
					if (tmpPoint2dIterator.next().flag == 'c') {
						point2ds[index].flag = 'b';
						countNonNoise += 1;
						break;
					}
				}
				if (point2ds[index].flag == 'u')
					point2ds[index].flag = 'n';
			}

		}
	}

	private class Point2d {
		char flag; // u: unknown ; c: core ; b: border ; n: noise
		public double x, y;
		public LinkedList<Point2d> neighborPoints;

		public Point2d(double tmpx, double tmpy) {
			flag = 'u';
			x = tmpx;
			y = tmpy;
			neighborPoints = new LinkedList<Point2d>();
		}
	}

	private class CorePoint2d extends Point2d {

		public CorePoint2d(double tmpx, double tmpy) {
			super(tmpx, tmpy);
		}

	}
}
